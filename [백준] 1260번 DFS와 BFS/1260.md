# [백준] 1260번 DFS와 BFS
[백준 1260](https://www.acmicpc.net/problem/1260)<br>
![문제](https://postfiles.pstatic.net/MjAyNTA2MDVfNiAg/MDAxNzQ5MTM0MTY5MDE3.-DkdYnQJRWAL1YBvp02Ikbf2PoNQ0KuYmeFYjVWVY7Yg.F6r9MKfh11RfoQf2TDOBrOc5NI8i-rA7I3wjRFOHcMsg.PNG/image.png?type=w773)<br>
<br>
지난번에 다뤘던 BFS와 DFS를 구현하기만 하는 문제이다.

다만 주의할 점은 아래와 같다. 

(1) **그래프가 양방향이기 때문에** x->y 방향만 저장하면 안되고 y->x방향도 저장해주어야한다는 것

(2) 정점 번호가 1부터 시작하기 때문에 배열의 크기를 1 늘려주어야 한다는 것

(3) 숫자가 작은 정점부터 탐색해야하므로 DFS할 때 스택에 큰 숫자부터 넣어야 한다는 것

(4) DFS: 꺼낼 때 방문 처리<br>
    BFS: 넣을 때 방문 처리<br>
    * 둘 다 꺼낼 때 출력

## 소스코드
```cpp
#include <iostream>
#include <stack>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

void dfs(int start, const vector<vector<int>>& graph);
void bfs(int start, const vector<vector<int>>& graph);
int main() {
	int n, m, v; //정점, 간선, 시작
	cin >> n >> m >> v;

	vector<vector<int>> graph(n + 1);
	for (int i = 0; i < m; i++) {
		int x, y;
		cin >> x >> y;

		graph[x].push_back(y);
		graph[y].push_back(x); //양방향이므로!!
	}

	for (int i = 1; i <= n; i++) {
		sort(graph[i].begin(), graph[i].end());
	}

	dfs(v, graph);
	cout << endl;
	bfs(v, graph);

}
void dfs(int start, const vector<vector<int>>& graph) {

	stack<int> s;
	vector<bool> visited(graph.size() + 1);
	s.push(start);

	while (!s.empty()) {
		int j = s.top();
		s.pop();

		if (!visited[j]) {
			visited[j] = true; //꺼낼 때 visited
			cout << j << " "; 

			for (int i = graph[j].size() - 1; i >= 0; i--) {
				int next = graph[j][i];
				if (!visited[next]) {
					s.push(next);
				}
			}
		}
	}
}

void bfs(int start, const vector<vector<int>>& graph) {

	queue<int> q;
	vector<int> visited(graph.size() + 1);

	visited[start] = true;
	q.push(start);

	while (!q.empty()) {
		int j = q.front();
		q.pop();
		cout << j << " ";

		for (int i = 0; i < graph[j].size(); i++) {
			int next = graph[j][i];
			if (!visited[next]) {
				q.push(next);
				visited[next] = true; //넣을 때 visited
			}
		}
	}
}
```
